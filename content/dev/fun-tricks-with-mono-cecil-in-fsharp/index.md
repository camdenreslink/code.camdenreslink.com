+++
title = "Fun Tricks with Mono.Cecil in F#"
subtitle = "Using Mono.Cecil to Discover Things About Your .NET Projects"
bannerFigCaption = ""
date = "2018-02-24"
summary = "Static code analysis is the process of investigating the structure of a program without actually executing it (as opposed to things that happen at runtime like reflection, logging, running unit tests, or debugging). In this post, we'll be investigating interesting ways to leverage the Mono.Cecil library to analyze .NET projects."
draft=true
+++

*Disclaimer: Some of the things described in this post can probably be accomplished with the [.NET Compiler Platform (i.e. Roslyn)](https://github.com/dotnet/roslyn). I haven't had a chance to play around with that yet, so I use Mono.Cecil for similar tasks.*

Background
==========

Static code analysis is the process of investigating the structure of a program without actually executing it (as opposed to things that happen at runtime like reflection, logging, running unit tests, or debugging). This can be done via examining an [Abstract Syntax Tree (AST)](https://github.com/dotnet/roslyn/wiki/Getting-Started-C%23-Syntax-Analysis) generated by parsing the C#/VB/F# source code. It can also be accomplished by analyzing the [Common Intermediate Language (CIL)](https://en.wikipedia.org/wiki/Common_Intermediate_Language) bytecode generated by compiling your .NET applications. We will be using the latter strategy.

*Note: CIL bytecode is sometimes also called IL, MSIL (Microsoft Intermediate Language), or just "bytecode".*

CIL bytecode is what gets generated when you compile a .NET application. This bytecode then gets run using a CIL compatible runtime (.NET Framework, .NET Core, or Mono).

TODO: Graph depicting Source File -> CIL Bytecode -> Runtime executing code on processor

If you've never seen CIL Bytecode before, try installing an extension for Visual Studio called [ILSpy](https://github.com/icsharpcode/ILSpy) (coincidentally, this tool was written using Mono.Cecil, the topic of this blog post). This tool will allow you to right click on a method or class in Visual Studio and select "Open code in ILSpy". A window will appear with the IL instructions that correspond to that method or class.

{{< figure-resource resource="img/screenshot_ILSpy.png" >}}

Mono.Cecil
==========

[Mono.Cecil](https://github.com/jbevain/cecil) is a library that analyzes a file containing IL instructions (a `.dll` or `.exe` assembly file), and creates a traversable data structure describing that assembly. Despite its name, it can be used for IL code compiled to run against the .NET Framework, not just Mono. It also allows for the rewriting of IL instructions. So, you can modify the assembly to customize its behavior even after it has been compiled. This is sometimes referred to as *IL Weaving*, and is how [Aspect Oriented Programming (AOP)](https://www.postsharp.net/aop.net) is accomplished. Cecil is a very popular library, and is used in all sorts of open source and commercial projects. See a list [here](https://github.com/jbevain/cecil/wiki/Users).

Sample Project to Analyze
=========================

*We will be using [Visual Studio 2017 Community Edition](https://www.visualstudio.com/vs/community/). You could use Visual Studio Code with modifications to some of the steps.*

If we're going to be writing code that analyzes .NET code, we're going to need some an example project to analyze. Instead of writing this example code, I decided to use an open source project called [SmartStoreNET](http://www.smartstore.com/en/net). It is an e-commerce shopping cart solution implemented using ASP.NET MVC.

To get our work environment set up, we need to complete the following steps:

1. Clone the SmartStoreNET repository: [Link to the repository](https://github.com/smartstoreag/SmartStoreNET)
2. Navigate to `SmartStoreNET\src\` and open `SmartStoreNET.sln` in Visual Studio.
3. Restore the NuGet packages, and build the solution.
4. We now have an entire directory of assemblies that we can play around with located at `SmartStoreNET\src\Presentation\SmartStore.Web\bin`.

Setting Up Our Analyzer Project
===============================

We will be using F# to do our analysis. I like to use F#, because it allows you to write in a functional style while providing nice integration with the .NET platform. This gives your F# code the ability to interop with libraries that were originally intended to be used with C#. An excellent source to learn more about F# is the [F# for Fun and Profit](https://fsharpforfunandprofit.com/site-contents/) website authored by Scott Wlaschin.

Open Visual Studio, and select `File > New > Project`. Within the New Project window, navigate to the "Visual F#" section and select "Console Application". Choose a name and location for your project. I chose to name mine "Mono.Cecil_FunTricks". The paths in the rest of this post will assume this project name.

{{< figure-resource resource="img/screenshot_NewProject.png" >}}

*Note: If you don't already have F# language tools installed for Visual Studio, you'll have to do that. Within Visual Studio, go to `Tools > Get Tools and Features`. This will open the Visual Studio Installer window. Under the Individual Components tab, navigate to the Development Activities header and make sure "F# language support" is checked. Then click the "Modify" button located on the bottom right corner of the window. All Visual Studio windows need to be closed for the installer to work.*

I will be using [Paket](https://fsprojects.github.io/Paket/) to manage my dependencies. To read more about the benefits of Paket, check out the [FAQ](https://fsprojects.github.io/Paket/faq.html). To set up Paket:

1. Navigate in the file explorer to the root directory of our solution: `Mono.Cecil_FunTricks\`.
2. Create a directory named `.paket`. You may get an error saying "You must type a file name." You get this error whenever you try creating a directory that starts with a period character. To circumvent this, create a directory named `.paket.`. Windows will automatically truncate the last period character leaving us with our desired directory name. (I got that tip [here](https://superuser.com/a/483763) after having some trouble with it).
3. Download the latest [paket.bootstrapper.exe](https://github.com/fsprojects/Paket/releases/latest) file into the `.paket` directory.
4. Run `.paket/paket.bootstrapper.exe`. It will download the latest `paket.exe` into the `.paket` directory.
5. Create a file named `paket.dependencies` in the root directory of our solution: `Mono.Cecil_FunTricks\`. Add the following lines to this file:`source https://nuget.org/api/v2`, `nuget Mono.Cecil`
6. Navigate to the directory containing your F# project (`.fsproj`), and create a file named `paket.references` in it. Add the following line to this file: `Mono.Cecil`.

So, we should have the following:

{{< highlight-custom language="text" header-text="paket.dependencies" >}}
source https://nuget.org/api/v2

nuget Mono.Cecil
{{< /highlight-custom >}}

{{< highlight-custom language="text" header-text="paket.references" >}}
Mono.Cecil
{{< /highlight-custom >}}

Try running the following command from the root of your solution to install your packages:
{{< highlight-custom language="text" header-text="command line" >}}
.paket/paket.exe install
{{< /highlight-custom >}}

We should now be ready to start modifying and building our F# source code!

A Quick Mono.Cecil Test
=======================

We will do a quick test, just to make sure that we can use Cecil, and our project is set up correctly. Copy and paste the following F# content into `Mono.Cecil_FunTricks\Mono.Cecil_FunTricks\Program.fs`.

{{< highlight-custom language="fsharp" header-text="Program.fs" >}}
open Mono.Cecil

let openFile (filePath:string) = AssemblyDefinition.ReadAssembly filePath

[<EntryPoint>]
let main argv = 
    let assembly = openFile argv.[0]
    0 (* return an integer exit code *)
{{< /highlight-custom >}}

Now in Visual Studio, right click on the project `Mono.Cecil_FunTricks` in the Solution Explorer, and select Properties from the context menu. Navigate to `Debug > Start Options > Command line arguments:` and enter the following path into the text area: `{absolute path to the SmartStoreNET repository}\SmartStoreNET\src\Presentation\SmartStore.Web\bin\SmartStore.Web.dll`. Note: Make sure you fill in the path to the SmartStoreNET repository!

Add a breakpoint within the main function, and debug. You should see a value if you hover over the assembly value. We are now successfully statically analyzing our sample assembly!

{{< figure-resource resource="img/screenshot_QuickTest.png" >}}

**The rest of this post will take the form of different types of analysis you can do using Mono.Cecil**

Using Mono.Cecil as a Super-Charged Query Engine
================================================

During development, sometimes you have conditions in your head about some class you want to find in the codebase. Maybe you know something about its name, generic parameters, inheritance relationships, composition relationships, constructor signatures, etc. Sometimes the tools built in to Visual Studio or [ReSharper](https://www.jetbrains.com/resharper/) can't do exactly what is necessary to hunt down this mystery class. 

Mono.Cecil is ultimately flexible in finding any class/property/method/etc in your code based on any conditions you can dream up (that are representable in IL). The only cost, that isn't present when using an out-of-the-box solution, is that you must actually code your query by hand.

Some Plumbing Code
------------------

In Mono.Cecil you must explicitly load all of the assemblies that you want to query the types of. This has to be done manually, but it is usually pretty easy because all of the assemblies you want to inspect all reside in the same bin directory. Add the following assembly loader module to your F# project:

{{< highlight-custom language="fsharp" header-text="AssemblyLoader.fs" >}}
module AssemblyLoader

open Mono.Cecil
open System.IO

let LoadAssembly (assemblyPath: string) = 
    AssemblyDefinition.ReadAssembly assemblyPath

let LoadAllAssembliesByPrefix prefix binDirectoryPath =
    Directory.GetFiles (binDirectoryPath, sprintf "%s*" prefix) 
        |> Array.filter (fun f -> f.EndsWith ".dll" || f.EndsWith ".exe")
        |> Array.map LoadAssembly
{{< /highlight-custom >}}

*Note: AssemblyLoader.fs must be higher in your Solution Explorer than Program.fs and any other files that reference it. In F#, files must be in the correct order, and modules/functions/values can only be referenced if they've already been defined. Move a file in Visual Studio, by highlighting it in the Solution Explorer, and typing `alt-up` or `alt-down`*

Now change our Program.fs to call the new assembly loading code. Change the debug command line argument to be the bin directory of the SmartStore.Web project (it was a specific assembly before).
{{< highlight-custom language="fsharp" header-text="Program.fs" >}}
open Mono.Cecil

[<EntryPoint>]
let main argv = 
    let prefix = "SmartStore"
    (* We want to exclude SmartStore.Licensing, because it's a weird
       obfuscated assembly that we don't have the source for, so it
       isn't relevant to our analysis. *)
    let assemblies = (AssemblyLoader.LoadAllAssembliesByPrefix prefix argv.[0])
                        |> Array.filter (fun a -> 
                            a.MainModule.Name <> "SmartStore.Licensing.dll")

    0 (* return an integer exit code *)
{{< /highlight-custom >}}

We can now start iterating through these loaded assemblies, and finding our desired Types.

Find All Classes Implementing Some Interface
--------------------------------------------

We'll start out with a simple example. Let's find all classes that exist in our assemblies that implement the IDisposable interface. We'll create another file to contain all of our custom queries. Add the following file to your solution:
{{< highlight-custom language="fsharp" header-text="AssemblyQueries.fs" >}}
module AssemblyQueries

open Mono.Cecil

let FindAllTypesImplementingInterface interfaceFullName (assembly: AssemblyDefinition) =
    assembly.Modules
        |> Seq.collect (fun m -> m.Types)
        |> Seq.filter (fun t -> t.Interfaces 
                               |> Seq.exists (fun i -> 
                                    i.FullName = interfaceFullName))
{{< /highlight-custom >}}

We can now add calling code to the main program:
{{< highlight-custom language="fsharp" header-text="Program.fs" >}}
open Mono.Cecil

[<EntryPoint>]
let main argv = 
    let prefix = "SmartStore"

    (* We want to exclude SmartStore.Licensing, because it's a weird
       obfuscated assembly that we don't have the source for, so it
       isn't relevant to our analysis. *)
    let assemblies = (AssemblyLoader.LoadAllAssembliesByPrefix prefix argv.[0])
                        |> Array.filter (fun a -> 
                            a.MainModule.Name <> "SmartStore.Licensing.dll")
    
    let disposableTypes = assemblies 
                            |> Seq.collect (AssemblyQueries.FindAllTypesImplementingInterface 
                                typeof<System.IDisposable>.FullName)
                            |> Seq.toArray

    0 (* return an integer exit code *)
{{< /highlight-custom >}}


Debug your solution, and you should see all of the disposable types across the SmartStore.NET solution (19 total in my version of the program).

A Little Refactoring
--------------------

F# being a functional language allows us to be a little bit more generic in our implementation. Take a look at the following function. Notice how it's very similar to our interface finding code, but could handle any given query based on a passed in predicate. This will help with code reuse.

{{< highlight-custom language="fsharp" header-text="F#" >}}
let FilterTypes predicate (assembly: AssemblyDefinition) =
    assembly.Modules
    |> Seq.collect (fun m -> m.Types)
    |> Seq.filter predicate
{{< /highlight-custom >}}

Now we can rewrite our previous module using this new helper function. I think it's much cleaner this way:
{{< highlight-custom language="fsharp" header-text="AssemblyQueries.fs" >}}
module AssemblyQueries

open Mono.Cecil

let FilterTypes predicate (assembly: AssemblyDefinition) =
    assembly.Modules
    |> Seq.collect (fun m -> m.Types)
    |> Seq.filter predicate

let FindAllTypesImplementingInterface interfaceFullName (assembly: AssemblyDefinition) =
    let findMatchingInterfaces (t: TypeDefinition) = 
        t.Interfaces 
            |> Seq.exists (fun i -> 
                i.FullName = interfaceFullName)
    assembly |> FilterTypes findMatchingInterfaces
{{< /highlight-custom >}}

Build a Class Dependency Graph
==============================

In C#, a class can contain a reference to another class via a field or property. This is called *composition* in object oriented programming. It is used when two classes share a "HAS A" relationship with each other (for example a Dog class HAS A Tail class). The class of the referenced property can then have its own fields/properties, creating a graph of vertices (.NET classes) and directed edges (an edge from E to V means that E contains a reference to V). You can brush up on some basic graph theory [here](https://en.wikipedia.org/wiki/Graph_theory). I also like [this MIT lecture](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/lecture-6-graph-theory-and-coloring/) taught by Tom Leighton (co-founder and current CEO of Akamai, one of the top CDNs in the world!).

Sometimes it can be helpful to visualize this dependency graph to see the relationships between different classes in your application (or even classes in libraries that you pull in). For example, you may be surprised that a top level class includes a reference indirectly through nested composition to some other class. Or you may be surprised to find cycles in this graph. Or it can be helpful to see how deeply nested this thing gets. The more nesting there is, the harder it is to reason about your application.